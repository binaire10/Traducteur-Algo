#pragma once
#include <string>

const std::string CodeBeg =
        "fonction TrouveCarDansStr (Caract : in caractere, "
        "                           Chaine : in string, "
        "                           Debut  : in entier_naturel) renvoie entier_naturel\n"
        "debut\n"
        "    declarer i : entier_naturel;\n"
        "    i <- Debut;\n"
        "    tant_que (i < taille(Chaine) ET_ALORS Caract ne_vaut_pas Chaine[i])\n"
        "    faire\n"
        "        i <- i +1;\n"
        "    ffaire\n"
        "    renvoie i;\n"
        "fin\n"
        "\n"
        "fonction isupper (Car : in caractere) renvoie booleen\n"
        "debut\n"
        "    renvoie ('A' <= Car ET_ALORS Car <= 'Z');\n"
        "fin\n"
        "\n"
        "fonction islower (Car : in caractere) renvoie booleen\n"
        "debut\n"
        "    renvoie ('a' <= Car ET_ALORS Car <= 'z');\n"
        "fin\n"
        "\n"
        "procedure MajTabFreq (TabFreq : in_out tableau_de entier_naturel, LettresTrouvees : in_out string, Chaine : in string)\n"
        "debut\n"
        "\n"
        "    declarer CarCou : caractere;\n"
        "    declarer Pos : entier_naturel;\n"
        "    declarer TabFreqPos : entier_naturel;\n"
        "    choix_sur CarCou entre\n"
        "       cas 'A':\n"
        "       Pos <- 0;\n"
        "       cas 'B':\n"
        "       Pos <- 12;\n"
        "    fchoix\n"
        "    pour (i variant_de 0 a taille (Chaine) - 1)\n"
        "    faire\n"
        "        si (NON (islower (Chaine[i]) OU_SINON isupper (Chaine[i]))) continue; \n"
        "        CarCou <- tolower (Chaine[i]);\n"
        "        Pos <- TrouveCarDansStr (CarCou, LettresTrouvees, 0);\n"
        "\n"
        "        si (Pos vaut taille (LettresTrouvees))\n"
        "            LettresTrouvees <- LettresTrouvees + CarCou;\n"
        "            allonger (TabFreq, 1);\n"
        "            TabFreqPos <- 0;\n"
        "        fsi\n"
        "        TabFreqPos <- TabFreqPos + 1;\n"
        "    ffaire\n"
        "fin\n"
        "\n"
        "fonction FctSomme (TabEnt : in tableau_de entier_naturel) renvoie entier_naturel\n"
        "debut\n"
        "    declarer Somme : entier_naturel;\n"
        "    Somme <- 0;\n"
        "    pour (i variant_de 0  a taille (TabEnt) - 1)\n"
        "    faire\n"
        "        Somme <- Somme + TabEnt[i];\n"
        "    ffaire\n"
        "    renvoie Somme;\n"
        "fin\n"
        "\n"
        "\n"
        "procedure AffichTabFreq (LettresTrouvees : in string, TabFreq : in tableau_de entier_naturel)\n"
        "debut\n"
        "    declarer Somme : entier_naturel;\n"
        "    Somme <- FctSomme (TabFreq);\n"
        "    pour (i variant_de 0 a taille (LettresTrouvees) - 1)\n"
        "    faire\n"
        "        afficher (LettresTrouvees[i], ' ', TabFreq[i] * 100 / Somme, '%');\n"
        "        ligne_suivante;\n"
        "    ffaire\n"
        "fin\n"
        "\n"
        "\n"/**
        "choix_sur variable_de_choix entre\n"
        "  cas Valeur_1 :\n"
        "      Sequence_1;\n"
        "\n"
        "  cas Valeur_2 :\n"
        "      Sequence_2;\n"
        "\n"
        "  cas Valeur_n :\n"
        "      Sequence_n;\n"
        "\n"
        "  autre :\n"
        "      TraitementAutre;\n"
        "fchoix"
        "\n"**/
        "\n"
        "algorithme ComptageDynamique\n"
        "debut\n"
        "    declarer LigneLue : string;\n"
        "    declarer TabFreq : tableau_de entier_naturel;\n"
        "    declarer LettresTrouvees : string;\n"
        "    \n"
        "    boucle\n"
        "        afficher (\"Saisir une ligne : \");\n"
        "        saisir (LigneLue);\n"
        "        si (taille (LigneLue) vaut 0) sortie;\n"
        "        MajTabFreq (TabFreq, LettresTrouvees, LigneLue);\n"
        "        AffichTabFreq (LettresTrouvees, TabFreq);\n"
        "\n"
        "    fboucle\n"
        "fin\n";

const std::string oklm("                fonction GenereTabInt (N : in entier_naturel) renvoie tableau_de entier\n"
                  "                debut\n"
                  "                \n"
                  "                    declarer TabInt : tableau_de N entier;\n"
                  "                \n"
                  "                    pour (i variant_de 0 a N - 1)\n"
                  "                    faire\n"
                  "                        afficher (\"entrer la \", i, \"éme valeur du tableau : \");\n"
                  "                        //saisir (TabInt [i]);\n"
                  "                        declarer Val : entier;\n"
                  "                        saisir (Val);\n"
                  "                        TabInt [i] <- Val;\n"
                  "                    ffaire\n"
                  "                    renvoie TabInt;\n"
                  "                fin\n"
                  "                \n"
                  "                procedure AfficheTabInt (TabInt : in tableau_de entier)\n"
                  "                debut\n"
                  "                    pour (i variant_de 0 a taille(TabInt) - 1)\n"
                  "                    faire\n"
                  "                        afficher (TabInt [i], \" \");\n"
                  "                    ffaire\n"
                  "                    ligne_suivante;\n"
                  "                fin\n"
                  "                \n"
                  "                algorithme UtilisationDeAfficheTabIntEtDeGenereTabInt\n"
                  "                debut\n"
                  "                    declarer N : entier_naturel;\n"
                  "                    afficher (\"entrer la taille du tableau : \");\n"
                  "                    saisir (N);"
                  "                \n"
                  "                    declarer TabInts : tableau_de entier;\n"
                  "                "
                  "                    TabInts <- GenereTabInt (N);\n"
                  "                \n"
                  "                    AfficheTabInt (TabInts);\n"
                  "                fin\n");

const std::string oklm2("fonction isupper (Car : in caractere) renvoie booleen\n"
                   "debut\n"
                   "    renvoie ('A' <= Car ET_ALORS Car <= 'Z');\n"
                   "fin\n"
                   "\n"
                   "fonction islower (Car : in caractere) renvoie booleen\n"
                   "debut\n"
                   "    renvoie ('a' <= Car ET_ALORS Car <= 'z');\n"
                   "fin\n"
                   "\n"
                   "fonction isdigit (Car : in caractere) renvoie booleen\n"
                   "debut\n"
                   "    renvoie ('0' <= Car ET_ALORS Car <= '9');\n"
                   "fin\n"
                   "\n"
                   "fonction CarDeMot (Car : in caractere) renvoie booleen\n"
                   "debut\n"
                   "    renvoie (islower (Car) OU_SINON isupper(Car) OU_SINON isdigit (Car) OU_SINON Car vaut '_');\n"
                   "fin\n"
                   "\n"
                   "//approche mot/mot\n"
                   "fonction CompterNbMots (Chaine : in string) renvoie entier_naturel\n"
                   "debut\n"
                   "    declarer Cpt : entier_naturel;\n"
                   "    Cpt <- 0;\n"
                   "    declarer i : entier_naturel;\n"
                   "    i <- taille (Chaine) - 1;\n"
                   "\n"
                   "    boucle \n"
                   "        //on se positionne sur le début du prochain mot\n"
                   "        tant_que ((i > 0) ET_ALORS  (NON CarDeMot (Chaine [i]))) \n"
                   "        faire\n"
                   "            i <- i - 1;\n"
                   "        ffaire\n"
                   "        //si Chaine [0] est un mot constitue d'une unique lettre, il ne faut pas sortir\n"
                   "        si (i vaut 0 ET_ALORS NON CarDeMot (Chaine [i])) sortie;\n"
                   "                \n"
                   "        //si on ne sort pas, c'est qu'on est sur le debut d'un mot\n"
                   "        Cpt <- Cpt + 1;\n"
                   "        \n"
                   "        //on passe le mot courant\n"
                   "        repeter \n"
                   "            i <- i - 1;\n"
                   "        jusqua (i > 0 ET_ALORS CarDeMot (Chaine [i])) \n"
                   "        //on test l'etat dans lequel on est sorti\n"
                   "        //si (i vaut 0 ET_ALORS CarDeMot (Chaine [i])) alors c'est que la chaine commence par un mot\n"
                   "        //puisque i vaut 0, on peut sortir de la boucle\n"
                   "        si (i vaut 0 ET_ALORS CarDeMot (Chaine [i])) sortie;\n"
                   "    fboucle\n"
                   "    \n"
                   "    renvoie Cpt;\n"
                   "fin\n"
                   "\n"
                   "//approche caractere/caractere\n"
                   "//fonction CompterNbMots (Chaine : in string) renvoie entier_naturel\n"
                   "//debut\n"
                   "//    declarer Cpt : entier_naturel;\n"
                   "//    Cpt <- 0;\n"
                   "//    declarer EstDansMot : booleen;\n"
                   "//    EstDansMot <- faux;\n"
                   "//    \n"
                   "//    pour (i variant_de  taille (Chaine) -1 a 0 descendant)\n"
                   "//    faire\n"
                   "//        //on identifie le debut d'un nouveau mot\n"
                   "//        si (NON EstDansMot ET_ALORS CarDeMot (Chaine [i]))\n"
                   "//            Cpt <- Cpt + 1;\n"
                   "//            EstDansMot <- vrai;\n"
                   "//        //on identifie la fin du mot courant\n"
                   "//        sinon_si (EstDansMot ET_ALORS NON CarDeMot (Chaine [i]))\n"
                   "//            EstDansMot <- faux;\n"
                   "//        fsi\n"
                   "//    ffaire\n"
                   "//    renvoie Cpt;\n"
                   "//fin\n"
                   "\n"
                   "\n"
                   "algorithme ComptageDeMots\n"
                   "debut\n"
                   "    declarer LigneLue : string;\n"
                   "    boucle\n"
                   "        afficher (\"Entrer une ligne : \");\n"
                   "        saisir (LigneLue);\n"
                   "        si (0 vaut taille (LigneLue)) sortie;\n"
                   "        afficher (LigneLue);\n"
                   "        ligne_suivante;\n"
                   "        afficher (\"Nombre de mots de la ligne :\", CompterNbMots (LigneLue));\n"
                   "        ligne_suivante;\n"
                   "    fboucle\n"
                   "fin\n");


const std::string oklm3("fonction NbMonotonies (Tab : in tableau_de entier) renvoie entier_naturel\n"
                  "debut\n"
                  "    declarer Nb : entier_naturel;\n"
                  "    si (taille (Tab) vaut 0)\n"
                  "        Nb <- 0;\n"
                  "    sinon\n"
                  "        Nb <- 1;\n"
                  "    fsi\n"
                  "    pour (i variant_de 1 a taille (Tab) - 1)\n"
                  "    faire\n"
                  "        si (Tab[i] < Tab[i] - 1)\n"
                  "            Nb <- Nb + 1;\n"
                  "        fsi\n"
                  "    ffaire\n"
                  "\n"
                  "    renvoie Nb;\n"
                  "    \n"
                  "fin\n");
